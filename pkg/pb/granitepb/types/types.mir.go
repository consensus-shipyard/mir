// Code generated by Mir codegen. DO NOT EDIT.

package granitepbtypes

import (
	mirreflect "github.com/filecoin-project/mir/codegen/mirreflect"
	types "github.com/filecoin-project/mir/pkg/granite/types"
	granitepb "github.com/filecoin-project/mir/pkg/pb/granitepb"
	types1 "github.com/filecoin-project/mir/pkg/pb/trantorpb/types"
	reflectutil "github.com/filecoin-project/mir/pkg/util/reflectutil"
)

type Message struct {
	Type Message_Type
}

type Message_Type interface {
	mirreflect.GeneratedType
	isMessage_Type()
	Pb() granitepb.Message_Type
}

type Message_TypeWrapper[T any] interface {
	Message_Type
	Unwrap() *T
}

func Message_TypeFromPb(pb granitepb.Message_Type) Message_Type {
	if pb == nil {
		return nil
	}
	switch pb := pb.(type) {
	case *granitepb.Message_Converge:
		return &Message_Converge{Converge: ConvergeFromPb(pb.Converge)}
	case *granitepb.Message_Propose:
		return &Message_Propose{Propose: ProposeFromPb(pb.Propose)}
	case *granitepb.Message_Prepare:
		return &Message_Prepare{Prepare: PrepareFromPb(pb.Prepare)}
	case *granitepb.Message_Commit:
		return &Message_Commit{Commit: CommitFromPb(pb.Commit)}
	case *granitepb.Message_Decision:
		return &Message_Decision{Decision: DecisionFromPb(pb.Decision)}
	case *granitepb.Message_ConsensusMsg:
		return &Message_ConsensusMsg{ConsensusMsg: ConsensusMsgFromPb(pb.ConsensusMsg)}
	}
	return nil
}

type Message_Converge struct {
	Converge *Converge
}

func (*Message_Converge) isMessage_Type() {}

func (w *Message_Converge) Unwrap() *Converge {
	return w.Converge
}

func (w *Message_Converge) Pb() granitepb.Message_Type {
	if w == nil {
		return nil
	}
	if w.Converge == nil {
		return &granitepb.Message_Converge{}
	}
	return &granitepb.Message_Converge{Converge: (w.Converge).Pb()}
}

func (*Message_Converge) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*granitepb.Message_Converge]()}
}

type Message_Propose struct {
	Propose *Propose
}

func (*Message_Propose) isMessage_Type() {}

func (w *Message_Propose) Unwrap() *Propose {
	return w.Propose
}

func (w *Message_Propose) Pb() granitepb.Message_Type {
	if w == nil {
		return nil
	}
	if w.Propose == nil {
		return &granitepb.Message_Propose{}
	}
	return &granitepb.Message_Propose{Propose: (w.Propose).Pb()}
}

func (*Message_Propose) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*granitepb.Message_Propose]()}
}

type Message_Prepare struct {
	Prepare *Prepare
}

func (*Message_Prepare) isMessage_Type() {}

func (w *Message_Prepare) Unwrap() *Prepare {
	return w.Prepare
}

func (w *Message_Prepare) Pb() granitepb.Message_Type {
	if w == nil {
		return nil
	}
	if w.Prepare == nil {
		return &granitepb.Message_Prepare{}
	}
	return &granitepb.Message_Prepare{Prepare: (w.Prepare).Pb()}
}

func (*Message_Prepare) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*granitepb.Message_Prepare]()}
}

type Message_Commit struct {
	Commit *Commit
}

func (*Message_Commit) isMessage_Type() {}

func (w *Message_Commit) Unwrap() *Commit {
	return w.Commit
}

func (w *Message_Commit) Pb() granitepb.Message_Type {
	if w == nil {
		return nil
	}
	if w.Commit == nil {
		return &granitepb.Message_Commit{}
	}
	return &granitepb.Message_Commit{Commit: (w.Commit).Pb()}
}

func (*Message_Commit) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*granitepb.Message_Commit]()}
}

type Message_Decision struct {
	Decision *Decision
}

func (*Message_Decision) isMessage_Type() {}

func (w *Message_Decision) Unwrap() *Decision {
	return w.Decision
}

func (w *Message_Decision) Pb() granitepb.Message_Type {
	if w == nil {
		return nil
	}
	if w.Decision == nil {
		return &granitepb.Message_Decision{}
	}
	return &granitepb.Message_Decision{Decision: (w.Decision).Pb()}
}

func (*Message_Decision) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*granitepb.Message_Decision]()}
}

type Message_ConsensusMsg struct {
	ConsensusMsg *ConsensusMsg
}

func (*Message_ConsensusMsg) isMessage_Type() {}

func (w *Message_ConsensusMsg) Unwrap() *ConsensusMsg {
	return w.ConsensusMsg
}

func (w *Message_ConsensusMsg) Pb() granitepb.Message_Type {
	if w == nil {
		return nil
	}
	if w.ConsensusMsg == nil {
		return &granitepb.Message_ConsensusMsg{}
	}
	return &granitepb.Message_ConsensusMsg{ConsensusMsg: (w.ConsensusMsg).Pb()}
}

func (*Message_ConsensusMsg) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*granitepb.Message_ConsensusMsg]()}
}

func MessageFromPb(pb *granitepb.Message) *Message {
	if pb == nil {
		return nil
	}
	return &Message{
		Type: Message_TypeFromPb(pb.Type),
	}
}

func (m *Message) Pb() *granitepb.Message {
	if m == nil {
		return nil
	}
	pbMessage := &granitepb.Message{}
	{
		if m.Type != nil {
			pbMessage.Type = (m.Type).Pb()
		}
	}

	return pbMessage
}

func (*Message) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*granitepb.Message]()}
}

type ConsensusMsg struct {
	MsgType   types.MsgType
	Round     types.RoundNr
	Data      []uint8
	Ticket    *Ticket
	Signature []uint8
}

func ConsensusMsgFromPb(pb *granitepb.ConsensusMsg) *ConsensusMsg {
	if pb == nil {
		return nil
	}
	return &ConsensusMsg{
		MsgType:   (types.MsgType)(pb.MsgType),
		Round:     (types.RoundNr)(pb.Round),
		Data:      pb.Data,
		Ticket:    TicketFromPb(pb.Ticket),
		Signature: pb.Signature,
	}
}

func (m *ConsensusMsg) Pb() *granitepb.ConsensusMsg {
	if m == nil {
		return nil
	}
	pbMessage := &granitepb.ConsensusMsg{}
	{
		pbMessage.MsgType = (int32)(m.MsgType)
		pbMessage.Round = (uint64)(m.Round)
		pbMessage.Data = m.Data
		if m.Ticket != nil {
			pbMessage.Ticket = (m.Ticket).Pb()
		}
		pbMessage.Signature = m.Signature
	}

	return pbMessage
}

func (*ConsensusMsg) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*granitepb.ConsensusMsg]()}
}

type Converge struct {
	Round     types.RoundNr
	Data      []uint8
	Ticket    *Ticket
	Signature []uint8
}

func ConvergeFromPb(pb *granitepb.Converge) *Converge {
	if pb == nil {
		return nil
	}
	return &Converge{
		Round:     (types.RoundNr)(pb.Round),
		Data:      pb.Data,
		Ticket:    TicketFromPb(pb.Ticket),
		Signature: pb.Signature,
	}
}

func (m *Converge) Pb() *granitepb.Converge {
	if m == nil {
		return nil
	}
	pbMessage := &granitepb.Converge{}
	{
		pbMessage.Round = (uint64)(m.Round)
		pbMessage.Data = m.Data
		if m.Ticket != nil {
			pbMessage.Ticket = (m.Ticket).Pb()
		}
		pbMessage.Signature = m.Signature
	}

	return pbMessage
}

func (*Converge) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*granitepb.Converge]()}
}

type Ticket struct {
	Data []uint8
}

func TicketFromPb(pb *granitepb.Ticket) *Ticket {
	if pb == nil {
		return nil
	}
	return &Ticket{
		Data: pb.Data,
	}
}

func (m *Ticket) Pb() *granitepb.Ticket {
	if m == nil {
		return nil
	}
	pbMessage := &granitepb.Ticket{}
	{
		pbMessage.Data = m.Data
	}

	return pbMessage
}

func (*Ticket) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*granitepb.Ticket]()}
}

type Propose struct {
	Round     types.RoundNr
	Data      []uint8
	Signature []uint8
}

func ProposeFromPb(pb *granitepb.Propose) *Propose {
	if pb == nil {
		return nil
	}
	return &Propose{
		Round:     (types.RoundNr)(pb.Round),
		Data:      pb.Data,
		Signature: pb.Signature,
	}
}

func (m *Propose) Pb() *granitepb.Propose {
	if m == nil {
		return nil
	}
	pbMessage := &granitepb.Propose{}
	{
		pbMessage.Round = (uint64)(m.Round)
		pbMessage.Data = m.Data
		pbMessage.Signature = m.Signature
	}

	return pbMessage
}

func (*Propose) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*granitepb.Propose]()}
}

type Prepare struct {
	Round     types.RoundNr
	Data      []uint8
	Signature []uint8
}

func PrepareFromPb(pb *granitepb.Prepare) *Prepare {
	if pb == nil {
		return nil
	}
	return &Prepare{
		Round:     (types.RoundNr)(pb.Round),
		Data:      pb.Data,
		Signature: pb.Signature,
	}
}

func (m *Prepare) Pb() *granitepb.Prepare {
	if m == nil {
		return nil
	}
	pbMessage := &granitepb.Prepare{}
	{
		pbMessage.Round = (uint64)(m.Round)
		pbMessage.Data = m.Data
		pbMessage.Signature = m.Signature
	}

	return pbMessage
}

func (*Prepare) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*granitepb.Prepare]()}
}

type Commit struct {
	Round     types.RoundNr
	Data      []uint8
	Signature []uint8
}

func CommitFromPb(pb *granitepb.Commit) *Commit {
	if pb == nil {
		return nil
	}
	return &Commit{
		Round:     (types.RoundNr)(pb.Round),
		Data:      pb.Data,
		Signature: pb.Signature,
	}
}

func (m *Commit) Pb() *granitepb.Commit {
	if m == nil {
		return nil
	}
	pbMessage := &granitepb.Commit{}
	{
		pbMessage.Round = (uint64)(m.Round)
		pbMessage.Data = m.Data
		pbMessage.Signature = m.Signature
	}

	return pbMessage
}

func (*Commit) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*granitepb.Commit]()}
}

type Decision struct {
	Data      []uint8
	Signature []uint8
}

func DecisionFromPb(pb *granitepb.Decision) *Decision {
	if pb == nil {
		return nil
	}
	return &Decision{
		Data:      pb.Data,
		Signature: pb.Signature,
	}
}

func (m *Decision) Pb() *granitepb.Decision {
	if m == nil {
		return nil
	}
	pbMessage := &granitepb.Decision{}
	{
		pbMessage.Data = m.Data
		pbMessage.Signature = m.Signature
	}

	return pbMessage
}

func (*Decision) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*granitepb.Decision]()}
}

type InstanceParams struct {
	InstanceUid uint64
	Membership  *types1.Membership
}

func InstanceParamsFromPb(pb *granitepb.InstanceParams) *InstanceParams {
	if pb == nil {
		return nil
	}
	return &InstanceParams{
		InstanceUid: pb.InstanceUid,
		Membership:  types1.MembershipFromPb(pb.Membership),
	}
}

func (m *InstanceParams) Pb() *granitepb.InstanceParams {
	if m == nil {
		return nil
	}
	pbMessage := &granitepb.InstanceParams{}
	{
		pbMessage.InstanceUid = m.InstanceUid
		if m.Membership != nil {
			pbMessage.Membership = (m.Membership).Pb()
		}
	}

	return pbMessage
}

func (*InstanceParams) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*granitepb.InstanceParams]()}
}
