// Code generated by Mir codegen. DO NOT EDIT.

package batchdbpbtypes

import (
	mirreflect "github.com/filecoin-project/mir/codegen/mirreflect"
	types2 "github.com/filecoin-project/mir/codegen/model/types"
	types "github.com/filecoin-project/mir/pkg/availability/multisigcollector/types"
	batchdbpb "github.com/filecoin-project/mir/pkg/pb/availabilitypb/batchdbpb"
	types4 "github.com/filecoin-project/mir/pkg/pb/contextstorepb/types"
	types5 "github.com/filecoin-project/mir/pkg/pb/dslpb/types"
	trantorpb "github.com/filecoin-project/mir/pkg/pb/trantorpb"
	types1 "github.com/filecoin-project/mir/pkg/pb/trantorpb/types"
	types3 "github.com/filecoin-project/mir/pkg/trantor/types"
	reflectutil "github.com/filecoin-project/mir/pkg/util/reflectutil"
	stdtypes "github.com/filecoin-project/mir/stdtypes"
)

type Event struct {
	Type Event_Type
}

type Event_Type interface {
	mirreflect.GeneratedType
	isEvent_Type()
	Pb() batchdbpb.Event_Type
}

type Event_TypeWrapper[T any] interface {
	Event_Type
	Unwrap() *T
}

func Event_TypeFromPb(pb batchdbpb.Event_Type) Event_Type {
	if pb == nil {
		return nil
	}
	switch pb := pb.(type) {
	case *batchdbpb.Event_Lookup:
		return &Event_Lookup{Lookup: LookupBatchFromPb(pb.Lookup)}
	case *batchdbpb.Event_LookupResponse:
		return &Event_LookupResponse{LookupResponse: LookupBatchResponseFromPb(pb.LookupResponse)}
	case *batchdbpb.Event_Store:
		return &Event_Store{Store: StoreBatchFromPb(pb.Store)}
	case *batchdbpb.Event_Stored:
		return &Event_Stored{Stored: BatchStoredFromPb(pb.Stored)}
	case *batchdbpb.Event_GarbageCollect:
		return &Event_GarbageCollect{GarbageCollect: GarbageCollectFromPb(pb.GarbageCollect)}
	}
	return nil
}

type Event_Lookup struct {
	Lookup *LookupBatch
}

func (*Event_Lookup) isEvent_Type() {}

func (w *Event_Lookup) Unwrap() *LookupBatch {
	return w.Lookup
}

func (w *Event_Lookup) Pb() batchdbpb.Event_Type {
	if w == nil {
		return nil
	}
	if w.Lookup == nil {
		return &batchdbpb.Event_Lookup{}
	}
	return &batchdbpb.Event_Lookup{Lookup: (w.Lookup).Pb()}
}

func (*Event_Lookup) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*batchdbpb.Event_Lookup]()}
}

type Event_LookupResponse struct {
	LookupResponse *LookupBatchResponse
}

func (*Event_LookupResponse) isEvent_Type() {}

func (w *Event_LookupResponse) Unwrap() *LookupBatchResponse {
	return w.LookupResponse
}

func (w *Event_LookupResponse) Pb() batchdbpb.Event_Type {
	if w == nil {
		return nil
	}
	if w.LookupResponse == nil {
		return &batchdbpb.Event_LookupResponse{}
	}
	return &batchdbpb.Event_LookupResponse{LookupResponse: (w.LookupResponse).Pb()}
}

func (*Event_LookupResponse) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*batchdbpb.Event_LookupResponse]()}
}

type Event_Store struct {
	Store *StoreBatch
}

func (*Event_Store) isEvent_Type() {}

func (w *Event_Store) Unwrap() *StoreBatch {
	return w.Store
}

func (w *Event_Store) Pb() batchdbpb.Event_Type {
	if w == nil {
		return nil
	}
	if w.Store == nil {
		return &batchdbpb.Event_Store{}
	}
	return &batchdbpb.Event_Store{Store: (w.Store).Pb()}
}

func (*Event_Store) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*batchdbpb.Event_Store]()}
}

type Event_Stored struct {
	Stored *BatchStored
}

func (*Event_Stored) isEvent_Type() {}

func (w *Event_Stored) Unwrap() *BatchStored {
	return w.Stored
}

func (w *Event_Stored) Pb() batchdbpb.Event_Type {
	if w == nil {
		return nil
	}
	if w.Stored == nil {
		return &batchdbpb.Event_Stored{}
	}
	return &batchdbpb.Event_Stored{Stored: (w.Stored).Pb()}
}

func (*Event_Stored) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*batchdbpb.Event_Stored]()}
}

type Event_GarbageCollect struct {
	GarbageCollect *GarbageCollect
}

func (*Event_GarbageCollect) isEvent_Type() {}

func (w *Event_GarbageCollect) Unwrap() *GarbageCollect {
	return w.GarbageCollect
}

func (w *Event_GarbageCollect) Pb() batchdbpb.Event_Type {
	if w == nil {
		return nil
	}
	if w.GarbageCollect == nil {
		return &batchdbpb.Event_GarbageCollect{}
	}
	return &batchdbpb.Event_GarbageCollect{GarbageCollect: (w.GarbageCollect).Pb()}
}

func (*Event_GarbageCollect) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*batchdbpb.Event_GarbageCollect]()}
}

func EventFromPb(pb *batchdbpb.Event) *Event {
	if pb == nil {
		return nil
	}
	return &Event{
		Type: Event_TypeFromPb(pb.Type),
	}
}

func (m *Event) Pb() *batchdbpb.Event {
	if m == nil {
		return nil
	}
	pbMessage := &batchdbpb.Event{}
	{
		if m.Type != nil {
			pbMessage.Type = (m.Type).Pb()
		}
	}

	return pbMessage
}

func (*Event) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*batchdbpb.Event]()}
}

type LookupBatch struct {
	BatchId types.BatchID
	Origin  *LookupBatchOrigin
}

func LookupBatchFromPb(pb *batchdbpb.LookupBatch) *LookupBatch {
	if pb == nil {
		return nil
	}
	return &LookupBatch{
		BatchId: (types.BatchID)(pb.BatchId),
		Origin:  LookupBatchOriginFromPb(pb.Origin),
	}
}

func (m *LookupBatch) Pb() *batchdbpb.LookupBatch {
	if m == nil {
		return nil
	}
	pbMessage := &batchdbpb.LookupBatch{}
	{
		pbMessage.BatchId = ([]uint8)(m.BatchId)
		if m.Origin != nil {
			pbMessage.Origin = (m.Origin).Pb()
		}
	}

	return pbMessage
}

func (*LookupBatch) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*batchdbpb.LookupBatch]()}
}

type LookupBatchResponse struct {
	Found  bool
	Txs    []*types1.Transaction
	Origin *LookupBatchOrigin
}

func LookupBatchResponseFromPb(pb *batchdbpb.LookupBatchResponse) *LookupBatchResponse {
	if pb == nil {
		return nil
	}
	return &LookupBatchResponse{
		Found: pb.Found,
		Txs: types2.ConvertSlice(pb.Txs, func(t *trantorpb.Transaction) *types1.Transaction {
			return types1.TransactionFromPb(t)
		}),
		Origin: LookupBatchOriginFromPb(pb.Origin),
	}
}

func (m *LookupBatchResponse) Pb() *batchdbpb.LookupBatchResponse {
	if m == nil {
		return nil
	}
	pbMessage := &batchdbpb.LookupBatchResponse{}
	{
		pbMessage.Found = m.Found
		pbMessage.Txs = types2.ConvertSlice(m.Txs, func(t *types1.Transaction) *trantorpb.Transaction {
			return (t).Pb()
		})
		if m.Origin != nil {
			pbMessage.Origin = (m.Origin).Pb()
		}
	}

	return pbMessage
}

func (*LookupBatchResponse) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*batchdbpb.LookupBatchResponse]()}
}

type StoreBatch struct {
	BatchId        types.BatchID
	Txs            []*types1.Transaction
	RetentionIndex types3.RetentionIndex
	Origin         *StoreBatchOrigin
}

func StoreBatchFromPb(pb *batchdbpb.StoreBatch) *StoreBatch {
	if pb == nil {
		return nil
	}
	return &StoreBatch{
		BatchId: (types.BatchID)(pb.BatchId),
		Txs: types2.ConvertSlice(pb.Txs, func(t *trantorpb.Transaction) *types1.Transaction {
			return types1.TransactionFromPb(t)
		}),
		RetentionIndex: (types3.RetentionIndex)(pb.RetentionIndex),
		Origin:         StoreBatchOriginFromPb(pb.Origin),
	}
}

func (m *StoreBatch) Pb() *batchdbpb.StoreBatch {
	if m == nil {
		return nil
	}
	pbMessage := &batchdbpb.StoreBatch{}
	{
		pbMessage.BatchId = ([]uint8)(m.BatchId)
		pbMessage.Txs = types2.ConvertSlice(m.Txs, func(t *types1.Transaction) *trantorpb.Transaction {
			return (t).Pb()
		})
		pbMessage.RetentionIndex = (uint64)(m.RetentionIndex)
		if m.Origin != nil {
			pbMessage.Origin = (m.Origin).Pb()
		}
	}

	return pbMessage
}

func (*StoreBatch) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*batchdbpb.StoreBatch]()}
}

type BatchStored struct {
	Origin *StoreBatchOrigin
}

func BatchStoredFromPb(pb *batchdbpb.BatchStored) *BatchStored {
	if pb == nil {
		return nil
	}
	return &BatchStored{
		Origin: StoreBatchOriginFromPb(pb.Origin),
	}
}

func (m *BatchStored) Pb() *batchdbpb.BatchStored {
	if m == nil {
		return nil
	}
	pbMessage := &batchdbpb.BatchStored{}
	{
		if m.Origin != nil {
			pbMessage.Origin = (m.Origin).Pb()
		}
	}

	return pbMessage
}

func (*BatchStored) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*batchdbpb.BatchStored]()}
}

type GarbageCollect struct {
	RetentionIndex types3.RetentionIndex
}

func GarbageCollectFromPb(pb *batchdbpb.GarbageCollect) *GarbageCollect {
	if pb == nil {
		return nil
	}
	return &GarbageCollect{
		RetentionIndex: (types3.RetentionIndex)(pb.RetentionIndex),
	}
}

func (m *GarbageCollect) Pb() *batchdbpb.GarbageCollect {
	if m == nil {
		return nil
	}
	pbMessage := &batchdbpb.GarbageCollect{}
	{
		pbMessage.RetentionIndex = (uint64)(m.RetentionIndex)
	}

	return pbMessage
}

func (*GarbageCollect) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*batchdbpb.GarbageCollect]()}
}

type LookupBatchOrigin struct {
	Module stdtypes.ModuleID
	Type   LookupBatchOrigin_Type
}

type LookupBatchOrigin_Type interface {
	mirreflect.GeneratedType
	isLookupBatchOrigin_Type()
	Pb() batchdbpb.LookupBatchOrigin_Type
}

type LookupBatchOrigin_TypeWrapper[T any] interface {
	LookupBatchOrigin_Type
	Unwrap() *T
}

func LookupBatchOrigin_TypeFromPb(pb batchdbpb.LookupBatchOrigin_Type) LookupBatchOrigin_Type {
	if pb == nil {
		return nil
	}
	switch pb := pb.(type) {
	case *batchdbpb.LookupBatchOrigin_ContextStore:
		return &LookupBatchOrigin_ContextStore{ContextStore: types4.OriginFromPb(pb.ContextStore)}
	case *batchdbpb.LookupBatchOrigin_Dsl:
		return &LookupBatchOrigin_Dsl{Dsl: types5.OriginFromPb(pb.Dsl)}
	}
	return nil
}

type LookupBatchOrigin_ContextStore struct {
	ContextStore *types4.Origin
}

func (*LookupBatchOrigin_ContextStore) isLookupBatchOrigin_Type() {}

func (w *LookupBatchOrigin_ContextStore) Unwrap() *types4.Origin {
	return w.ContextStore
}

func (w *LookupBatchOrigin_ContextStore) Pb() batchdbpb.LookupBatchOrigin_Type {
	if w == nil {
		return nil
	}
	if w.ContextStore == nil {
		return &batchdbpb.LookupBatchOrigin_ContextStore{}
	}
	return &batchdbpb.LookupBatchOrigin_ContextStore{ContextStore: (w.ContextStore).Pb()}
}

func (*LookupBatchOrigin_ContextStore) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*batchdbpb.LookupBatchOrigin_ContextStore]()}
}

type LookupBatchOrigin_Dsl struct {
	Dsl *types5.Origin
}

func (*LookupBatchOrigin_Dsl) isLookupBatchOrigin_Type() {}

func (w *LookupBatchOrigin_Dsl) Unwrap() *types5.Origin {
	return w.Dsl
}

func (w *LookupBatchOrigin_Dsl) Pb() batchdbpb.LookupBatchOrigin_Type {
	if w == nil {
		return nil
	}
	if w.Dsl == nil {
		return &batchdbpb.LookupBatchOrigin_Dsl{}
	}
	return &batchdbpb.LookupBatchOrigin_Dsl{Dsl: (w.Dsl).Pb()}
}

func (*LookupBatchOrigin_Dsl) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*batchdbpb.LookupBatchOrigin_Dsl]()}
}

func LookupBatchOriginFromPb(pb *batchdbpb.LookupBatchOrigin) *LookupBatchOrigin {
	if pb == nil {
		return nil
	}
	return &LookupBatchOrigin{
		Module: (stdtypes.ModuleID)(pb.Module),
		Type:   LookupBatchOrigin_TypeFromPb(pb.Type),
	}
}

func (m *LookupBatchOrigin) Pb() *batchdbpb.LookupBatchOrigin {
	if m == nil {
		return nil
	}
	pbMessage := &batchdbpb.LookupBatchOrigin{}
	{
		pbMessage.Module = (string)(m.Module)
		if m.Type != nil {
			pbMessage.Type = (m.Type).Pb()
		}
	}

	return pbMessage
}

func (*LookupBatchOrigin) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*batchdbpb.LookupBatchOrigin]()}
}

type StoreBatchOrigin struct {
	Module stdtypes.ModuleID
	Type   StoreBatchOrigin_Type
}

type StoreBatchOrigin_Type interface {
	mirreflect.GeneratedType
	isStoreBatchOrigin_Type()
	Pb() batchdbpb.StoreBatchOrigin_Type
}

type StoreBatchOrigin_TypeWrapper[T any] interface {
	StoreBatchOrigin_Type
	Unwrap() *T
}

func StoreBatchOrigin_TypeFromPb(pb batchdbpb.StoreBatchOrigin_Type) StoreBatchOrigin_Type {
	if pb == nil {
		return nil
	}
	switch pb := pb.(type) {
	case *batchdbpb.StoreBatchOrigin_ContextStore:
		return &StoreBatchOrigin_ContextStore{ContextStore: types4.OriginFromPb(pb.ContextStore)}
	case *batchdbpb.StoreBatchOrigin_Dsl:
		return &StoreBatchOrigin_Dsl{Dsl: types5.OriginFromPb(pb.Dsl)}
	}
	return nil
}

type StoreBatchOrigin_ContextStore struct {
	ContextStore *types4.Origin
}

func (*StoreBatchOrigin_ContextStore) isStoreBatchOrigin_Type() {}

func (w *StoreBatchOrigin_ContextStore) Unwrap() *types4.Origin {
	return w.ContextStore
}

func (w *StoreBatchOrigin_ContextStore) Pb() batchdbpb.StoreBatchOrigin_Type {
	if w == nil {
		return nil
	}
	if w.ContextStore == nil {
		return &batchdbpb.StoreBatchOrigin_ContextStore{}
	}
	return &batchdbpb.StoreBatchOrigin_ContextStore{ContextStore: (w.ContextStore).Pb()}
}

func (*StoreBatchOrigin_ContextStore) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*batchdbpb.StoreBatchOrigin_ContextStore]()}
}

type StoreBatchOrigin_Dsl struct {
	Dsl *types5.Origin
}

func (*StoreBatchOrigin_Dsl) isStoreBatchOrigin_Type() {}

func (w *StoreBatchOrigin_Dsl) Unwrap() *types5.Origin {
	return w.Dsl
}

func (w *StoreBatchOrigin_Dsl) Pb() batchdbpb.StoreBatchOrigin_Type {
	if w == nil {
		return nil
	}
	if w.Dsl == nil {
		return &batchdbpb.StoreBatchOrigin_Dsl{}
	}
	return &batchdbpb.StoreBatchOrigin_Dsl{Dsl: (w.Dsl).Pb()}
}

func (*StoreBatchOrigin_Dsl) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*batchdbpb.StoreBatchOrigin_Dsl]()}
}

func StoreBatchOriginFromPb(pb *batchdbpb.StoreBatchOrigin) *StoreBatchOrigin {
	if pb == nil {
		return nil
	}
	return &StoreBatchOrigin{
		Module: (stdtypes.ModuleID)(pb.Module),
		Type:   StoreBatchOrigin_TypeFromPb(pb.Type),
	}
}

func (m *StoreBatchOrigin) Pb() *batchdbpb.StoreBatchOrigin {
	if m == nil {
		return nil
	}
	pbMessage := &batchdbpb.StoreBatchOrigin{}
	{
		pbMessage.Module = (string)(m.Module)
		if m.Type != nil {
			pbMessage.Type = (m.Type).Pb()
		}
	}

	return pbMessage
}

func (*StoreBatchOrigin) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*batchdbpb.StoreBatchOrigin]()}
}
