// Code generated by Mir codegen. DO NOT EDIT.

package broadcastpbtypes

import (
	mirreflect "github.com/filecoin-project/mir/codegen/mirreflect"
	broadcastpb "github.com/filecoin-project/mir/pkg/pb/blockchainpb/broadcastpb"
	types "github.com/filecoin-project/mir/pkg/pb/blockchainpb/types"
	reflectutil "github.com/filecoin-project/mir/pkg/util/reflectutil"
)

type Event struct {
	Type Event_Type
}

type Event_Type interface {
	mirreflect.GeneratedType
	isEvent_Type()
	Pb() broadcastpb.Event_Type
}

type Event_TypeWrapper[T any] interface {
	Event_Type
	Unwrap() *T
}

func Event_TypeFromPb(pb broadcastpb.Event_Type) Event_Type {
	if pb == nil {
		return nil
	}
	switch pb := pb.(type) {
	case *broadcastpb.Event_NewBlock:
		return &Event_NewBlock{NewBlock: NewBlockFromPb(pb.NewBlock)}
	}
	return nil
}

type Event_NewBlock struct {
	NewBlock *NewBlock
}

func (*Event_NewBlock) isEvent_Type() {}

func (w *Event_NewBlock) Unwrap() *NewBlock {
	return w.NewBlock
}

func (w *Event_NewBlock) Pb() broadcastpb.Event_Type {
	if w == nil {
		return nil
	}
	if w.NewBlock == nil {
		return &broadcastpb.Event_NewBlock{}
	}
	return &broadcastpb.Event_NewBlock{NewBlock: (w.NewBlock).Pb()}
}

func (*Event_NewBlock) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*broadcastpb.Event_NewBlock]()}
}

func EventFromPb(pb *broadcastpb.Event) *Event {
	if pb == nil {
		return nil
	}
	return &Event{
		Type: Event_TypeFromPb(pb.Type),
	}
}

func (m *Event) Pb() *broadcastpb.Event {
	if m == nil {
		return nil
	}
	pbMessage := &broadcastpb.Event{}
	{
		if m.Type != nil {
			pbMessage.Type = (m.Type).Pb()
		}
	}

	return pbMessage
}

func (*Event) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*broadcastpb.Event]()}
}

type NewBlock struct {
	Block *types.Block
}

func NewBlockFromPb(pb *broadcastpb.NewBlock) *NewBlock {
	if pb == nil {
		return nil
	}
	return &NewBlock{
		Block: types.BlockFromPb(pb.Block),
	}
}

func (m *NewBlock) Pb() *broadcastpb.NewBlock {
	if m == nil {
		return nil
	}
	pbMessage := &broadcastpb.NewBlock{}
	{
		if m.Block != nil {
			pbMessage.Block = (m.Block).Pb()
		}
	}

	return pbMessage
}

func (*NewBlock) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*broadcastpb.NewBlock]()}
}

type Message struct {
	Type Message_Type
}

type Message_Type interface {
	mirreflect.GeneratedType
	isMessage_Type()
	Pb() broadcastpb.Message_Type
}

type Message_TypeWrapper[T any] interface {
	Message_Type
	Unwrap() *T
}

func Message_TypeFromPb(pb broadcastpb.Message_Type) Message_Type {
	if pb == nil {
		return nil
	}
	switch pb := pb.(type) {
	case *broadcastpb.Message_NewBlock:
		return &Message_NewBlock{NewBlock: NewBlockMessageFromPb(pb.NewBlock)}
	}
	return nil
}

type Message_NewBlock struct {
	NewBlock *NewBlockMessage
}

func (*Message_NewBlock) isMessage_Type() {}

func (w *Message_NewBlock) Unwrap() *NewBlockMessage {
	return w.NewBlock
}

func (w *Message_NewBlock) Pb() broadcastpb.Message_Type {
	if w == nil {
		return nil
	}
	if w.NewBlock == nil {
		return &broadcastpb.Message_NewBlock{}
	}
	return &broadcastpb.Message_NewBlock{NewBlock: (w.NewBlock).Pb()}
}

func (*Message_NewBlock) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*broadcastpb.Message_NewBlock]()}
}

func MessageFromPb(pb *broadcastpb.Message) *Message {
	if pb == nil {
		return nil
	}
	return &Message{
		Type: Message_TypeFromPb(pb.Type),
	}
}

func (m *Message) Pb() *broadcastpb.Message {
	if m == nil {
		return nil
	}
	pbMessage := &broadcastpb.Message{}
	{
		if m.Type != nil {
			pbMessage.Type = (m.Type).Pb()
		}
	}

	return pbMessage
}

func (*Message) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*broadcastpb.Message]()}
}

type NewBlockMessage struct {
	Block *types.Block
}

func NewBlockMessageFromPb(pb *broadcastpb.NewBlockMessage) *NewBlockMessage {
	if pb == nil {
		return nil
	}
	return &NewBlockMessage{
		Block: types.BlockFromPb(pb.Block),
	}
}

func (m *NewBlockMessage) Pb() *broadcastpb.NewBlockMessage {
	if m == nil {
		return nil
	}
	pbMessage := &broadcastpb.NewBlockMessage{}
	{
		if m.Block != nil {
			pbMessage.Block = (m.Block).Pb()
		}
	}

	return pbMessage
}

func (*NewBlockMessage) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*broadcastpb.NewBlockMessage]()}
}
