// Code generated by Mir codegen. DO NOT EDIT.

package applicationpbtypes

import (
	mirreflect "github.com/filecoin-project/mir/codegen/mirreflect"
	types2 "github.com/filecoin-project/mir/codegen/model/types"
	blockchainpb "github.com/filecoin-project/mir/pkg/pb/blockchainpb"
	applicationpb "github.com/filecoin-project/mir/pkg/pb/blockchainpb/applicationpb"
	types3 "github.com/filecoin-project/mir/pkg/pb/blockchainpb/payloadpb/types"
	types "github.com/filecoin-project/mir/pkg/pb/blockchainpb/statepb/types"
	types1 "github.com/filecoin-project/mir/pkg/pb/blockchainpb/types"
	reflectutil "github.com/filecoin-project/mir/pkg/util/reflectutil"
)

type Event struct {
	Type Event_Type
}

type Event_Type interface {
	mirreflect.GeneratedType
	isEvent_Type()
	Pb() applicationpb.Event_Type
}

type Event_TypeWrapper[T any] interface {
	Event_Type
	Unwrap() *T
}

func Event_TypeFromPb(pb applicationpb.Event_Type) Event_Type {
	if pb == nil {
		return nil
	}
	switch pb := pb.(type) {
	case *applicationpb.Event_VerifyBlockRequest:
		return &Event_VerifyBlockRequest{VerifyBlockRequest: VerifyBlocksRequestFromPb(pb.VerifyBlockRequest)}
	case *applicationpb.Event_VerifyBlockResponse:
		return &Event_VerifyBlockResponse{VerifyBlockResponse: VerifyBlocksResponseFromPb(pb.VerifyBlockResponse)}
	case *applicationpb.Event_PayloadRequest:
		return &Event_PayloadRequest{PayloadRequest: PayloadRequestFromPb(pb.PayloadRequest)}
	case *applicationpb.Event_PayloadResponse:
		return &Event_PayloadResponse{PayloadResponse: PayloadResponseFromPb(pb.PayloadResponse)}
	case *applicationpb.Event_HeadChange:
		return &Event_HeadChange{HeadChange: HeadChangeFromPb(pb.HeadChange)}
	case *applicationpb.Event_MessageInput:
		return &Event_MessageInput{MessageInput: MessageInputFromPb(pb.MessageInput)}
	}
	return nil
}

type Event_VerifyBlockRequest struct {
	VerifyBlockRequest *VerifyBlocksRequest
}

func (*Event_VerifyBlockRequest) isEvent_Type() {}

func (w *Event_VerifyBlockRequest) Unwrap() *VerifyBlocksRequest {
	return w.VerifyBlockRequest
}

func (w *Event_VerifyBlockRequest) Pb() applicationpb.Event_Type {
	if w == nil {
		return nil
	}
	if w.VerifyBlockRequest == nil {
		return &applicationpb.Event_VerifyBlockRequest{}
	}
	return &applicationpb.Event_VerifyBlockRequest{VerifyBlockRequest: (w.VerifyBlockRequest).Pb()}
}

func (*Event_VerifyBlockRequest) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*applicationpb.Event_VerifyBlockRequest]()}
}

type Event_VerifyBlockResponse struct {
	VerifyBlockResponse *VerifyBlocksResponse
}

func (*Event_VerifyBlockResponse) isEvent_Type() {}

func (w *Event_VerifyBlockResponse) Unwrap() *VerifyBlocksResponse {
	return w.VerifyBlockResponse
}

func (w *Event_VerifyBlockResponse) Pb() applicationpb.Event_Type {
	if w == nil {
		return nil
	}
	if w.VerifyBlockResponse == nil {
		return &applicationpb.Event_VerifyBlockResponse{}
	}
	return &applicationpb.Event_VerifyBlockResponse{VerifyBlockResponse: (w.VerifyBlockResponse).Pb()}
}

func (*Event_VerifyBlockResponse) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*applicationpb.Event_VerifyBlockResponse]()}
}

type Event_PayloadRequest struct {
	PayloadRequest *PayloadRequest
}

func (*Event_PayloadRequest) isEvent_Type() {}

func (w *Event_PayloadRequest) Unwrap() *PayloadRequest {
	return w.PayloadRequest
}

func (w *Event_PayloadRequest) Pb() applicationpb.Event_Type {
	if w == nil {
		return nil
	}
	if w.PayloadRequest == nil {
		return &applicationpb.Event_PayloadRequest{}
	}
	return &applicationpb.Event_PayloadRequest{PayloadRequest: (w.PayloadRequest).Pb()}
}

func (*Event_PayloadRequest) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*applicationpb.Event_PayloadRequest]()}
}

type Event_PayloadResponse struct {
	PayloadResponse *PayloadResponse
}

func (*Event_PayloadResponse) isEvent_Type() {}

func (w *Event_PayloadResponse) Unwrap() *PayloadResponse {
	return w.PayloadResponse
}

func (w *Event_PayloadResponse) Pb() applicationpb.Event_Type {
	if w == nil {
		return nil
	}
	if w.PayloadResponse == nil {
		return &applicationpb.Event_PayloadResponse{}
	}
	return &applicationpb.Event_PayloadResponse{PayloadResponse: (w.PayloadResponse).Pb()}
}

func (*Event_PayloadResponse) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*applicationpb.Event_PayloadResponse]()}
}

type Event_HeadChange struct {
	HeadChange *HeadChange
}

func (*Event_HeadChange) isEvent_Type() {}

func (w *Event_HeadChange) Unwrap() *HeadChange {
	return w.HeadChange
}

func (w *Event_HeadChange) Pb() applicationpb.Event_Type {
	if w == nil {
		return nil
	}
	if w.HeadChange == nil {
		return &applicationpb.Event_HeadChange{}
	}
	return &applicationpb.Event_HeadChange{HeadChange: (w.HeadChange).Pb()}
}

func (*Event_HeadChange) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*applicationpb.Event_HeadChange]()}
}

type Event_MessageInput struct {
	MessageInput *MessageInput
}

func (*Event_MessageInput) isEvent_Type() {}

func (w *Event_MessageInput) Unwrap() *MessageInput {
	return w.MessageInput
}

func (w *Event_MessageInput) Pb() applicationpb.Event_Type {
	if w == nil {
		return nil
	}
	if w.MessageInput == nil {
		return &applicationpb.Event_MessageInput{}
	}
	return &applicationpb.Event_MessageInput{MessageInput: (w.MessageInput).Pb()}
}

func (*Event_MessageInput) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*applicationpb.Event_MessageInput]()}
}

func EventFromPb(pb *applicationpb.Event) *Event {
	if pb == nil {
		return nil
	}
	return &Event{
		Type: Event_TypeFromPb(pb.Type),
	}
}

func (m *Event) Pb() *applicationpb.Event {
	if m == nil {
		return nil
	}
	pbMessage := &applicationpb.Event{}
	{
		if m.Type != nil {
			pbMessage.Type = (m.Type).Pb()
		}
	}

	return pbMessage
}

func (*Event) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*applicationpb.Event]()}
}

type VerifyBlocksRequest struct {
	CheckpointState        *types.State
	ChainCheckpointToStart []*types1.Block
	ChainToVerify          []*types1.Block
}

func VerifyBlocksRequestFromPb(pb *applicationpb.VerifyBlocksRequest) *VerifyBlocksRequest {
	if pb == nil {
		return nil
	}
	return &VerifyBlocksRequest{
		CheckpointState: types.StateFromPb(pb.CheckpointState),
		ChainCheckpointToStart: types2.ConvertSlice(pb.ChainCheckpointToStart, func(t *blockchainpb.Block) *types1.Block {
			return types1.BlockFromPb(t)
		}),
		ChainToVerify: types2.ConvertSlice(pb.ChainToVerify, func(t *blockchainpb.Block) *types1.Block {
			return types1.BlockFromPb(t)
		}),
	}
}

func (m *VerifyBlocksRequest) Pb() *applicationpb.VerifyBlocksRequest {
	if m == nil {
		return nil
	}
	pbMessage := &applicationpb.VerifyBlocksRequest{}
	{
		if m.CheckpointState != nil {
			pbMessage.CheckpointState = (m.CheckpointState).Pb()
		}
		pbMessage.ChainCheckpointToStart = types2.ConvertSlice(m.ChainCheckpointToStart, func(t *types1.Block) *blockchainpb.Block {
			return (t).Pb()
		})
		pbMessage.ChainToVerify = types2.ConvertSlice(m.ChainToVerify, func(t *types1.Block) *blockchainpb.Block {
			return (t).Pb()
		})
	}

	return pbMessage
}

func (*VerifyBlocksRequest) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*applicationpb.VerifyBlocksRequest]()}
}

type VerifyBlocksResponse struct {
	VerifiedBlocks []*types1.Block
}

func VerifyBlocksResponseFromPb(pb *applicationpb.VerifyBlocksResponse) *VerifyBlocksResponse {
	if pb == nil {
		return nil
	}
	return &VerifyBlocksResponse{
		VerifiedBlocks: types2.ConvertSlice(pb.VerifiedBlocks, func(t *blockchainpb.Block) *types1.Block {
			return types1.BlockFromPb(t)
		}),
	}
}

func (m *VerifyBlocksResponse) Pb() *applicationpb.VerifyBlocksResponse {
	if m == nil {
		return nil
	}
	pbMessage := &applicationpb.VerifyBlocksResponse{}
	{
		pbMessage.VerifiedBlocks = types2.ConvertSlice(m.VerifiedBlocks, func(t *types1.Block) *blockchainpb.Block {
			return (t).Pb()
		})
	}

	return pbMessage
}

func (*VerifyBlocksResponse) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*applicationpb.VerifyBlocksResponse]()}
}

type HeadChange struct {
	RemovedChain         []*types1.Block
	AddedChain           []*types1.Block
	CheckpointToForkRoot []*types1.Block
	CheckpointState      *types.State
}

func HeadChangeFromPb(pb *applicationpb.HeadChange) *HeadChange {
	if pb == nil {
		return nil
	}
	return &HeadChange{
		RemovedChain: types2.ConvertSlice(pb.RemovedChain, func(t *blockchainpb.Block) *types1.Block {
			return types1.BlockFromPb(t)
		}),
		AddedChain: types2.ConvertSlice(pb.AddedChain, func(t *blockchainpb.Block) *types1.Block {
			return types1.BlockFromPb(t)
		}),
		CheckpointToForkRoot: types2.ConvertSlice(pb.CheckpointToForkRoot, func(t *blockchainpb.Block) *types1.Block {
			return types1.BlockFromPb(t)
		}),
		CheckpointState: types.StateFromPb(pb.CheckpointState),
	}
}

func (m *HeadChange) Pb() *applicationpb.HeadChange {
	if m == nil {
		return nil
	}
	pbMessage := &applicationpb.HeadChange{}
	{
		pbMessage.RemovedChain = types2.ConvertSlice(m.RemovedChain, func(t *types1.Block) *blockchainpb.Block {
			return (t).Pb()
		})
		pbMessage.AddedChain = types2.ConvertSlice(m.AddedChain, func(t *types1.Block) *blockchainpb.Block {
			return (t).Pb()
		})
		pbMessage.CheckpointToForkRoot = types2.ConvertSlice(m.CheckpointToForkRoot, func(t *types1.Block) *blockchainpb.Block {
			return (t).Pb()
		})
		if m.CheckpointState != nil {
			pbMessage.CheckpointState = (m.CheckpointState).Pb()
		}
	}

	return pbMessage
}

func (*HeadChange) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*applicationpb.HeadChange]()}
}

type PayloadRequest struct {
	HeadId uint64
}

func PayloadRequestFromPb(pb *applicationpb.PayloadRequest) *PayloadRequest {
	if pb == nil {
		return nil
	}
	return &PayloadRequest{
		HeadId: pb.HeadId,
	}
}

func (m *PayloadRequest) Pb() *applicationpb.PayloadRequest {
	if m == nil {
		return nil
	}
	pbMessage := &applicationpb.PayloadRequest{}
	{
		pbMessage.HeadId = m.HeadId
	}

	return pbMessage
}

func (*PayloadRequest) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*applicationpb.PayloadRequest]()}
}

type PayloadResponse struct {
	HeadId  uint64
	Payload *types3.Payload
}

func PayloadResponseFromPb(pb *applicationpb.PayloadResponse) *PayloadResponse {
	if pb == nil {
		return nil
	}
	return &PayloadResponse{
		HeadId:  pb.HeadId,
		Payload: types3.PayloadFromPb(pb.Payload),
	}
}

func (m *PayloadResponse) Pb() *applicationpb.PayloadResponse {
	if m == nil {
		return nil
	}
	pbMessage := &applicationpb.PayloadResponse{}
	{
		pbMessage.HeadId = m.HeadId
		if m.Payload != nil {
			pbMessage.Payload = (m.Payload).Pb()
		}
	}

	return pbMessage
}

func (*PayloadResponse) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*applicationpb.PayloadResponse]()}
}

type MessageInput struct {
	Text string
}

func MessageInputFromPb(pb *applicationpb.MessageInput) *MessageInput {
	if pb == nil {
		return nil
	}
	return &MessageInput{
		Text: pb.Text,
	}
}

func (m *MessageInput) Pb() *applicationpb.MessageInput {
	if m == nil {
		return nil
	}
	pbMessage := &applicationpb.MessageInput{}
	{
		pbMessage.Text = m.Text
	}

	return pbMessage
}

func (*MessageInput) MirReflect() mirreflect.Type {
	return mirreflect.TypeImpl{PbType_: reflectutil.TypeOf[*applicationpb.MessageInput]()}
}
