package protoutil

import (
	"fmt"
	"github.com/filecoin-project/mir/pkg/util/reflectutil"
	"reflect"
	"unsafe"
)

// VerifyOneofWrapper verifies that type W is, or structurally identical to, a wrapper around type T generated by the
// protobuf compiler for an element of a "oneof" statement of type T.
// If VerifyOneofWrapper[W,T]() returns nil, then function UnsafeUnwrapOneofWrapper[W, T](...) is safe to execute.
//
// In case of changes to the protobuf API for go, this function may start rejecting valid combinations of W and T.
// However, regardless of the changes to the API, the safety of UnsafeUnwrapOneofWrapper[W, T](...) is guaranteed if
// VerifyOneofWrapper[W,T]() returns nil.
//
// Example:
//   the following protobuf specification:
//   ```
//     message Bar {}
//     message Foo {
//       oneof bar_or_baz {
//         Bar bar_option = 1;
//         int baz_option = 2;
//       }
//     }
//   ```
//   will cause protoc-gen-go to generate 4 types: Bar, Foo, Foo_BarOption, and Foo_BazOption.
//   Then VerifyOneofWrapper[Foo_BarOption, Bar]() and VerifyOneofWrapper[Foo_BazOption, int]() will return nil.
//
// TODO: this function would be unnecessary if protobuf wrappers exported a method Elem() that would return a reference to the underlying object. Consider writing a small protobuf plugin.
func VerifyOneofWrapper[W, T any]() error {
	wType := reflectutil.TypeOf[W]()
	tType := reflectutil.TypeOf[T]()
	genericWrapperType := reflectutil.TypeOf[genericOneofWrapper[T]]()

	if wType.Kind() != reflect.Struct || wType.NumField() != 1 {
		return fmt.Errorf("%s is supposed to be a struct with a single field of type *%s", wType.Name(), tType.Name())
	}
	if wType.Field(0).Type.Kind() != reflect.Pointer || wType.Field(0).Type.Elem() != tType {
		return fmt.Errorf("%s is supposed to be a struct with a single field of type *%s", wType.Name(), tType.Name())
	}
	if wType.Size() != genericWrapperType.Size() || wType.Align() != genericWrapperType.Align() {
		return fmt.Errorf("unexpected size or alignment for type %s", wType.Name())
	}
	if wType.Field(0).Offset != genericWrapperType.Field(0).Offset {
		return fmt.Errorf("unexpected field offset for type %s", wType.Name())
	}

	return nil
}

// UnsafeUnwrapOneofWrapper returns the underlying object from a wrapper generated by the protobuf compiler.
// It is only safe to invoke if VerifyOneofWrapper[W, T]() == nil. Otherwise, it may lead to undefined behaviour and
// memory corruption.
func UnsafeUnwrapOneofWrapper[W, T any](w *W) *T {
	return (*genericOneofWrapper[T])(unsafe.Pointer(w)).t
}

type genericOneofWrapper[T any] struct{ t *T }
