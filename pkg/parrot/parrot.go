// Package parrot provides a way of periodically repeating tasks.
// One can instantiate a Parrot and pass functions to it that the Parrot will periodically execute
// as long as an associated continuation condition is satisfied.
package parrot

import "github.com/filecoin-project/mir/pkg/events"

// job represents one of the jobs of the Parrot.
// A job contains a single task (a function) and associated metadata such as the repetition period,
// when the task needs to be executed next time, and the continuation condition.
type job struct {

	// Period of task execution, in ticks.
	period int

	// The task to be repeated.
	task func() *events.EventList

	// The continuation condition of the job.
	// This function is evaluated each time when the task is about to be executed.
	// If cond returns true, the Parrot executes the task.
	// If cond returns false, the Parrot does not execute the task and deletes the whole job forever.
	cond func() bool

	// Ticks left until the next attempt to execute the task.
	// Each time the task is executed, ticksLeft is set to period - 1.
	// It is then decremented on each invocation of Tick until it reaches 0.
	// When Tick is invoked and ticksLeft equals 0, the Parrot attempts to execute the task again.
	ticksLeft int
}

// Tick signals a step of logical time to the job.
// If the time period between the execution of the job elapsed,
// Tick attempts to execute the task, adding any events potentially produced by the task to eventAccumulator.
// Tick returns true if the job continues, false if the job has to stop
// (when the continuation condition evaluates to false).
func (j *job) Tick(eventAccumulator *events.EventList) bool {

	if j.ticksLeft > 0 {
		// If any ticks are left, just decrement the tick counter and continue.
		j.ticksLeft--
		return true
	} else if j.cond() {
		// If there are no more ticks left and the continuation condition is still true,
		// execute the task, reset the tick counter, and continue.
		eventAccumulator.PushBackList(j.task())
		j.ticksLeft = j.period - 1
		return true
	} else {
		// If the continuation condition is false, stop the job.
		return false
	}
}

// Parrot represents a "parrot" that can periodically repeat tasks.
type Parrot struct {

	// All the Parrot's jobs, each handling one repetitive task.
	jobs []job
}

// NewParrot returns an idle parrot that does not repeat anything.
// It can be given tasks by calling its Repeat method.
func NewParrot() *Parrot {
	return &Parrot{jobs: make([]job, 0)}
}

// Tick signals a step of logical time to the Parrot.
// Tick makes the Parrot execute all tasks that are due according to the logical time,
// returning a list of Events potentially produced by those tasks.
func (p *Parrot) Tick() *events.EventList {

	// Create a new list of jobs.
	// It will be filled with all the jobs in the Parrot's current list of jobs
	// except for those that need to be stopped after this tick.
	newJobs := make([]job, len(p.jobs))

	// Accumulator of events.
	// All events produced by the executed tasks will be added here.
	eventAcc := &events.EventList{}

	for _, j := range p.jobs {
		// Signal a tick of logical time to each job and capture the produced events.
		if j.Tick(eventAcc) {
			// If the job still continues running, add it to the new job list.
			newJobs = append(newJobs, j)
		}
	}

	// Replace the old job list by the new one and return all events generated by the executed tasks.
	p.jobs = newJobs
	return eventAcc
}

// Repeat makes the Parrot repeat a task every period ticks, as long as the continuation condition cond is satisfied.
// The parrot evaluates cond and executes the task immediately if cond returns true.
// It then continues executing the task every period calls to Tick.
// Each time the Parrot is about to execute the task, it evaluates cond.
// If cond returns false, the Parrot does not execute the task and stops executing it forever.
// Repeat returns the events produced by the first immediate execution of task.
func (p *Parrot) Repeat(period int, task func() *events.EventList, cond func() bool) *events.EventList {

	// Create a new job corresponding to the task.
	newJob := job{
		period:    period,
		task:      task,
		cond:      cond,
		ticksLeft: 0,
	}

	// If the continuation condition is satisfied, execute the task immediately
	// and add the job to the list of jobs for periodic execution.
	initialEvents := &events.EventList{}
	if newJob.Tick(initialEvents) {
		p.jobs = append(p.jobs, newJob)
	}

	// Return events produced by the initial execution of the task.
	// If the task did not execute, this list remains empty.
	return initialEvents
}
