syntax = "proto3";

package eventpb;

import "commonpb/commonpb.proto";
import "requestpb/requestpb.proto";
import "messagepb/messagepb.proto";
import "isspb/isspb.proto";
import "google/protobuf/wrappers.proto";
import "bcbpb/bcbpb.proto";
import "mempoolpb/mempoolpb.proto";
import "availabilitypb/availabilitypb.proto";
import "factorypb/factorypb.proto";
import "availabilitypb/batchdbpb/batchdbpb.proto";
import "batchfetcherpb/batchfetcherpb.proto";
import "threshcryptopb/threshcryptopb.proto";
import "pingpongpb/pingpongpb.proto";
import "checkpointpb/checkpointpb.proto";
import "ordererpb/ordererpb.proto";
import "hasherpb/hasherpb.proto";
import "cryptopb/cryptopb.proto";

import "mir/codegen_extensions.proto";

option go_package = "github.com/filecoin-project/mir/pkg/pb/eventpb";

// Event represents a state event to be injected into the state machine
message Event {
  option (mir.event_root) = true;

  // TODO, normalize naming, for instance Complete/Completed
  oneof type {
    option (mir.event_type) = true;

    Init                    init                    = 1;
    TimerEvent              timer                   = 2; // Timer events must be defined in this file, see below.

          hasherpb.Event    hasher                  = 8;
             bcbpb.Event    bcb                     = 28;
         mempoolpb.Event    mempool                 = 29;
    availabilitypb.Event    availability            = 30;
         batchdbpb.Event    batch_db                = 34;
    batchfetcherpb.Event    batch_fetcher           = 35;
    threshcryptopb.Event    thresh_crypto           = 36;
        pingpongpb.Event    ping_pong               = 37;
      checkpointpb.Event    checkpoint              = 38;
         factorypb.Event    factory                 = 33;
             isspb.Event    iss                     = 18;
         ordererpb.Event    orderer                 = 39;
          cryptopb.Event    crypto                  = 40;

    NewRequests             new_requests            = 7;
    SendMessage             send_message            = 15;
    MessageReceived         message_received        = 16;
    DeliverCert             deliver_cert            = 17;
    VerifyRequestSig        verify_request_sig      = 19;
    RequestSigVerified      request_sig_verified    = 20;
    StoreVerifiedRequest    store_verified_request  = 21;
    AppSnapshotRequest      app_snapshot_request    = 22;
    AppSnapshot             app_snapshot            = 23;
    AppRestoreState         app_restore_state       = 24;
    NewEpoch                new_epoch               = 31;
    NewConfig               new_config              = 32;

    // for unit-tests
    google.protobuf.StringValue testingString = 301;
    google.protobuf.UInt64Value testingUint   = 302;
  }

  // A list of follow-up events to process after this event has been processed.
  // This field is used if events need to be processed in a particular order.
  // For example, a message sending event must only be processed
  // after the corresponding entry has been persisted in the write-ahead log (WAL).
  // In this case, the WAL append event would be this event
  // and the next field would contain the message sending event.
  // (This is a hypothetical example, the WAL functionality is not implemented at a moment.)
  repeated Event next = 100 [(mir.omit_in_event_constructors) = true];

  string dest_module = 200 [(mir.type) = "github.com/filecoin-project/mir/pkg/types.ModuleID"];
}

message Init {
  option (mir.event) = true;
}

message NewRequests {
  option (mir.event) = true;
  repeated requestpb.Request requests = 1;
}

message SendMessage {
  option (mir.event) = true;

  messagepb.Message msg = 1;
  repeated string destinations = 2 [(mir.type) = "github.com/filecoin-project/mir/pkg/types.NodeID"];
}

message MessageReceived {
  option (mir.event) = true;

  string from = 1 [(mir.type) = "github.com/filecoin-project/mir/pkg/types.NodeID"];
  messagepb.Message msg = 2;
}

message DeliverCert {
  option (mir.event) = true;
  uint64 sn = 1 [(mir.type) = "github.com/filecoin-project/mir/pkg/types.SeqNr"];
  availabilitypb.Cert cert = 2;
}

message VerifyRequestSig {
  requestpb.Request request   = 1;
  bytes             signature = 2;
}

message RequestSigVerified {
  requestpb.Request request = 1;
  bool              valid   = 2;
  string            error   = 3;
}

message StoreVerifiedRequest {
  requestpb.Request request       = 1;
  bytes             data          = 2;
  bytes             authenticator = 3;
}

message AppSnapshotRequest {
  option (mir.event) = true;
  string reply_to = 1  [(mir.type) = "github.com/filecoin-project/mir/pkg/types.ModuleID"];;
}

message AppSnapshot {
  bytes                 app_data = 1;
}

message AppRestoreState {
  option (mir.event) = true;
  checkpointpb.StableCheckpoint checkpoint = 1;
}

message NewEpoch {
  option (mir.event) = true;
  uint64 epoch_nr = 1 [(mir.type) = "github.com/filecoin-project/mir/pkg/types.EpochNr"];
}

message NewConfig {
  option (mir.event) = true;
  uint64              epoch_nr   = 1 [(mir.type) = "github.com/filecoin-project/mir/pkg/types.EpochNr"];
  commonpb.Membership membership = 2;
}


// ======================================================================
// Timer events.
// ======================================================================
//
// Those events, unfortunately, need to be defined in this very file, because they recursively contain top-level Events.
// Protocol Buffers do not allow recursion across files, complaining about cyclic imports.
// If timer events were defined separately, a cyclic import would be inevitable.
// The main eventpb.proto file (this file) would need to include the timer event file,
// since the timer event is an option of the Event's oneof type field.
// But the timer event file also needs to import the main Event file, since timer events contain general Events.
// The only way to express this mutual dependency is having all dependent events defined in a single file.

message TimerEvent {
  option (mir.event_class) = true;

  oneof Type {
    option (mir.event_type) = true;

    TimerDelay  delay                   = 1;
    TimerRepeat repeat                  = 2;
    TimerGarbageCollect garbage_collect = 3;
  }
}

message TimerDelay {
  option (mir.event) = true;

  // TODO: The field name must not be `events`, since it conflicts with a package name in the generated code.
  //       This is a bug in the Mir code generator that should be fixed.
  repeated Event events_to_delay  = 1;
  uint64         delay            = 2 [(mir.type) = "github.com/filecoin-project/mir/pkg/types.TimeDuration"];
}

message TimerRepeat {
  option (mir.event) = true;
  repeated Event events_to_repeat = 1;
  uint64         delay            = 2 [(mir.type) = "github.com/filecoin-project/mir/pkg/types.TimeDuration"];
  uint64         retention_index  = 3 [(mir.type) = "github.com/filecoin-project/mir/pkg/types.RetentionIndex"];
}

message TimerGarbageCollect {
  option (mir.event) = true;
  uint64 retention_index = 1 [(mir.type) = "github.com/filecoin-project/mir/pkg/types.RetentionIndex"];
}
