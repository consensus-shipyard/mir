/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0

Refactored: 1
*/

package mir

import (
	"context"
	"fmt"
	"github.com/filecoin-project/mir/pkg/modules"
	t "github.com/filecoin-project/mir/pkg/types"
	"runtime/debug"

	"github.com/filecoin-project/mir/pkg/events"
)

// Input channels for the modules within the Node.
// the Node.process() method writes events
// to these channels to route them to the corresponding Node's modules.
type workChans map[t.ModuleID]chan *events.EventList

// NewWorkChans allocates and returns a pointer to a new workChas object.
// The returned workChans contain a channel for each module in modules.
func newWorkChans(modules modules.Modules) workChans {
	wc := make(map[t.ModuleID]chan *events.EventList)

	for moduleID := range modules {
		wc[moduleID] = make(chan *events.EventList)
	}

	return wc
}

// processEvents reads a single list of input Events from a work channel, strips off all associated follow-up Events,
// and processes the bare content of the list using the passed processing function.
// processEvents writes all the stripped off follow-up events along with any Events generated by the processing
// to the workItemInput channel, so they will be added to the workItems buffer for further processing.
//
// If the Node is configured to use an Interceptor, after having removed all follow-up Events,
// processEvents passes the list of input Events to the Interceptor.
//
// If exitC is closed, returns ErrStopped.
func (n *Node) processEvents(
	ctx context.Context,
	module modules.PassiveModule,
	eventSource <-chan *events.EventList,
) error {
	var eventsIn *events.EventList

	// Read input.
	select {
	case eventsIn = <-eventSource:
	case <-ctx.Done():
		return nil
	case <-n.workErrNotifier.ExitC():
		return nil
	}

	// Remove follow-up Events from the input EventList,
	// in order to re-insert them in the processing loop after the input events have been processed.
	plainEvents, followUps := eventsIn.StripFollowUps()

	// Intercept the (stripped of all follow-ups) events that are about to be processed.
	// This is only for debugging / diagnostic purposes.
	n.interceptEvents(plainEvents)

	// Process events.
	newEvents, err := safelyApplyEvents(module, plainEvents)
	if err != nil {
		return err
	}

	// Merge the pending follow-up Events with the newly generated Events.
	out := followUps.PushBackList(newEvents)

	// Return if no output was generated.
	// This is only an optimization to prevent the processor loop from handling empty EventLists.
	if out.Len() == 0 {
		return nil
	}

	// Write output.
	select {
	case n.moduleOutput <- out:
	case <-ctx.Done():
		return nil
	case <-n.workErrNotifier.ExitC():
		return nil
	}

	return nil
}

func safelyApplyEvents(
	module modules.PassiveModule,
	events *events.EventList,
) (result *events.EventList, err error) {
	defer func() {
		if r := recover(); r != nil {
			if rErr, ok := r.(error); ok {
				err = fmt.Errorf("module panicked: %w\nStack trace:\n%s", rErr, string(debug.Stack()))
			} else {
				err = fmt.Errorf("module panicked: %v\nStack trace:\n%s", r, string(debug.Stack()))
			}
		}
	}()

	return module.ApplyEvents(events)
}
