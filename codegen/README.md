# Mir code generator

## Motivation

One of the main hurdles in using Mir is the need to write a lot of boilerplate code.
It is further exacerbated when DSL is used as it relies on some additional boilerplate code.
There are a few major issues with it:
- Writing boilerplate is annoying and consumes a non-trivial amount of time and energy, making Mir less attractive for prototyping, which is, arguable, one of its main niches.
- It significantly complicates further evolution of Mir.
  A small change to the core or to the DSL may require manual changes to a large amount of already existing boilerplate code.
- It forces the [“waterfall”](https://en.wikipedia.org/wiki/Waterfall_model) model on the development of modules.
  Since any change to the event and message descriptions (currently, in `.proto` files) needs to be propagated to all the related boilerplate, the programmer is strongly disincentivized from making such changes and, thus, is incentivized to think through the implementation and decide which events and network messages will be used before they start to actually implementing the logic of the module.
  Such an approach is not always optimal for prototyping and exploration.

The code generator aims to addressing these problems and to generally making Mir a slightly higher level framework. It also may later simplify migration to a different model for representing events and network messages or even allow multiple such models to coexist by automatically converting between them when necessary.

## Usage

### Annotating the `.proto` definitions

TODO

### Running the code generator

See `protos/generate.go`.

The following order is important to avoid circular dependencies:

1. Compile the protbuf extensions:
    ```go
    //go:generate -command protoc-basic protoc --proto_path=. --go_out=../pkg/pb/ --go_opt=paths=source_relative

    // Generate the code for codegen extensions.
    //go:generate protoc-basic mir/codegen_extensions.proto
    //go:generate protoc-basic dsl/codegen_extensions.proto
    //go:generate protoc-basic net/codegen_extensions.proto
    ```
2. Compile the protoc plugin:
   ```go
    //go:generate go build -o ../codegen/protoc-plugin/protoc-gen-mir ../codegen/protoc-plugin
    ```
3. Run `protoc` with this plugin enabled on the `.proto` files containing the definitions of Mir events:
    ```go
   //go:generate -command protoc-events protoc --proto_path=. --go_out=../pkg/pb/ --go_opt=paths=source_relative --plugin=../codegen/protoc-plugin/protoc-gen-mir --mir_out=../pkg/pb --mir_opt=paths=source_relative

    // Generate the protoc-generated code for events and messages.
    //go:generate protoc-events commonpb/commonpb.proto
    //go:generate protoc-events messagepb/messagepb.proto
    //go:generate protoc-events requestpb/requestpb.proto
    //go:generate protoc-events eventpb/eventpb.proto
    //...
    ```
4. Finally, build and run the Mir code generator with the `protoc`-generated code as its input:
    ```go
    // Build the custom code generators.
    //go:generate go build -o ../codegen/generators/mir-std-gen/mir-std-gen.bin ../codegen/generators/mir-std-gen
    //go:generate -command std-gen ../codegen/generators/mir-std-gen/mir-std-gen.bin
    
    // Generate the Mir-generated code for events and messages.
    //go:generate std-gen "github.com/filecoin-project/mir/pkg/pb/eventpb"
    //go:generate std-gen "github.com/filecoin-project/mir/pkg/pb/messagepb"
    //go:generate std-gen "github.com/filecoin-project/mir/pkg/pb/bcbpb"
    //...
    ```

The Mir-generated code will be in sub-folders of the folder containing the protoc-generated code.

## Architecture

At the time of writing this README, Mir uses protobufs to represent events and network messages.
For a set of reasons (including flexibility, ease of implementation, and potential future migration to a different representation) the Mir code generator is *not* implemented as a protoc plugin.
Instead, it uses the Go code generated by `protoc` as its input.
It inspects this code using reflection.
Hence, the whole package containing the `protoc`-generated code must be compilable (i.e., contain no syntax errors).

We proceed by describing each of the components one by one.

### The protobuf extensions

Located in `protos/mir/codegen_extensions.proto`, `protos/dsl/codegen_extensions.proto`, and `protos/net/codegen_extensions.proto`.

These extensions are used to annotate the `.proto` definitions with Mir-specific information.

#### Dependencies

None

### Parsing the protobuf extensions

Code located in `codegen/annotations.go`.

The code in this file simply checks if a certain message is marked with a certain annotation.
This file also contains an important function called `ShouldGenerateMirType`, which determines whether a given protobuf message should be processed by the Mir code generator.

#### Dependencies

The protobuf extensions must be compiled with `protoc`.

### protoc plugin

Located in `codegen/protoc-plugin/main.go`.

It is a tiny plugin that slightly enriches the reflection information of the `protoc`-generated code.
Namely, for each protobuf message marked with one of Mir annotations, for each `oneof` in this message, the plugin generates a method named `Reflect[OneofName]Options` that returns the information about all the options of the `oneof`.

#### Example

```protobuf
// Protobuf definition.
message RequestCertOrigin {
  option (mir.struct) = true;

  string module = 1 [(mir.type) = "github.com/filecoin-project/mir/pkg/types.ModuleID"];
  oneof type {
    contextstorepb.Origin context_store = 2;
    dslpb.Origin          dsl           = 3;
  }
}
```

```go
// Code generated by the plugin.
func (*RequestCertOrigin) ReflectTypeOptions() []reflect.Type {
	return []reflect.Type{
		reflect.TypeOf((*RequestCertOrigin_ContextStore)(nil)),
		reflect.TypeOf((*RequestCertOrigin_Dsl)(nil)),
	}
}
```

#### Dependencies

`github.com/filecoin-projct/mir/codegen` -- the plugin uses the `ShouldGenerateMirType` function.

### The `Generator` interface and the `RunGenerator` function

Located in `codegen/generator.go`.

Code generation in Mir is organized in a modular way.
There are many small generators.
All of them implement the same interface located in `codegen/generator.go`:
```go
type Generator interface {
	Run(structTypes []reflect.Type) error
}
```

The `Run` method of a code generator takes as input a list of all struct types exported by a package and may potentially return an error.

[//]: # (In order to run a Generator on a given package, one must use the `RunGenerator` function located in the same file:)

One non-trivial implication of using reflection to parse the input is that the input package must actually be compiled into the same binary as the code generator itself.
This is solved by the `RunGenerator` function located in the same file:
```go
func RunGenerator[GeneratorType Generator](inputPkgPath string) error
```

This function acts as a meta-code-generator, i.e., it generates, compiles, and runs the code generator itself (see the implementation).
For this reason it accepts the code generator as a type parameter and imposes a few natural restrictions on it:
* It must be a concrete type that can be instantiated (i.e., not an interface).
* The type must be exported (i.e., start with a capital letter).
* It must be in a package that can be imported (i.e., not in a package named `main` or `internal`).

This list is likely to be not exhaustive and it is probably still possible to write a Generator that would satisfy all this condition but would not compile.
Hence, it is recommended to stay close to the existing examples in `codegen/generators`.

The `Run` method is invoked on a zero value of the generator type.

#### Example

TODO

#### Dependencies

None

## Code structure

TODO

## Standard code generators

## Creating a third-party code generator 
