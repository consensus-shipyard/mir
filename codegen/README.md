# Mir code generator

## Motivation

One of the main hurdles in using Mir is the need to write a lot of boilerplate code.
It is further exacerbated when DSL is used as it relies on some additional boilerplate code.
There are a few major issues with it:
- Writing boilerplate is annoying and consumes a non-trivial amount of time and energy, making Mir less attractive for prototyping, which is, arguably, one of its main niches.
- It significantly complicates further evolution of Mir.
  A small change to the core or to the DSL may require manual changes to a large amount of already existing boilerplate code.
- It forces the [“waterfall”](https://en.wikipedia.org/wiki/Waterfall_model) model on the development of modules.
  Since any change to the event and message descriptions (currently, in `.proto` files) needs to be propagated to all the related boilerplate, the programmer is strongly disincentivized from making such changes and, thus, is incentivized to think through the implementation and decide which events and network messages will be used before they start to actually implementing the logic of the module.
  Such an approach is not always optimal for prototyping and exploring new ideas.

The code generator aims to address these problems and to generally make Mir a higher level framework. It also may later simplify migration to a different model for representing events and network messages or even allow multiple such models to coexist by performing an automatic conversion between them when necessary.

## Usage

### Annotating the `.proto` definitions

See `protos/mir/codegen_extensions.proto`, `protos/dsl/codegen_extensions.proto`, and `protos/net/codegen_extensions.proto` for the list of extensions.

The code generator creates a of types separate from the ones generated by `protoc`.
The primary motivation for doing so is to allow more customization.
This customization is done using special annotations in the `.proto` files.

Moreover, the annotations help to keep things explicit and to avoid hard-coded rules and conventions such as inferring information about the semantics of a type from its name.

#### Mir structs

The most basic annotation is `option (mir.struct) = true;` in a proto message (not to be confused with network messages). Intuitively, it simply tells the code generator to process this message. In particular, to create a Mir-generated type for it.
Proto messages that have no Mir annotations are ignored by the Mir code generator.

Example:
```protobuf
message SigVerData {
  option (mir.struct) = true;

  repeated bytes data = 1;
}
```

#### The event hierarchy

Events in Mir are organized into a tree-like hierarchy.

The root of the hierarchy should be annotated with `option (mir.event_root) = true;`.
Moreover, it must have a oneof field (typically, named `type` or `Type`) annotated with `option (mir.event_type) = true;`. This oneof lists all the “children” of the root. 

Example (adopted from `protos/eventpb/event.proto`):
```protobuf
message Event {
  option (mir.event_root) = true;

  oneof type {
    option (mir.event_type) = true;

    Init         init = 1;
    Tick         tick = 2;
    bcbpb.Event  bcb  = 28;
  }

  string dest_module = 200 [(mir.type) = "github.com/filecoin-project/mir/pkg/types.ModuleID"];
}
```

An internal node of the hierarchy must be annotated with `option (mir.event_class) = true;` and must also contain a oneof field annotated with `option (mir.event_type) = true;`. This oneof lists all the “children” of the node.

Example (from `protos/bcbpb/bcbpb.proto`):
```protobuf
message Event {
  option (mir.event_class) = true;

  oneof type {
    option (mir.event_type) = true;

    BroadcastRequest request = 1;
    Deliver          deliver = 2;
  }
}
```

Finally, a “leaf” in the hierarchy is an actual event and it must be annotated with `option (mir.event) = true;`.

Example (from `protos/bcbpb/bcbpb.proto`):
```protobuf
message BroadcastRequest {
  option (mir.event) = true;

  bytes data = 1;
}
```

#### The network messages hierarchy

The hierarchy of network messages is similar to the hierarchy of events.
The annotations used are `net.message_root`, `net.message_class`, and `net.message` for the proto messages representing the nodes in the net message hierarchy and `option (net.message_type) = true;` for the oneof fields that list the children of a node.

#### Customizing the generated types

Unfortunately, protobuf data model is not as expressive as the Go data model.
One big difference is that Go allows for type a form of type aliases such as:
```go
type ModuleID string
```
This creates a major inconvenience as the programmer has to manually convert between the protobuf and Go types.
This becomes even more cumbersome with `repeated` fields (i.e., arrays),
to the point that some event handlers would consist mostly of the type conversion boilerplate.

This issue is addressed by the annotation `[(mir.type) = "full/package/path.TypeName"]`.
It allows to specify the type in the Mir-generated code that corresponds to the annotated field in a proto message. The type must be convertible to/from the type of the field.

Example:
```protobuf
message NodeSigsVerified {
  option (mir.event) = true;

  SigVerOrigin    origin   = 1 [(mir.origin_response) = true];
  repeated string node_ids = 2 [(mir.type) = "github.com/filecoin-project/mir/pkg/types.NodeID"];
  repeated bool   valid    = 3;
  repeated string errors   = 4 [(mir.type) = "error"];
  bool            all_ok   = 5;
}
```

Here, the `node_ids` field will be represented as a slice of `types.NodeID` in the generated code instead of `string`.
Similarly, the `errors` field will be represented as `[]error` instead of `[]string`.

A `string` field annotated with `[(mir.type) = "error"]` is an exception from the general rule that the type of the field must be convertible to/from the type of the field.
Indeed, in Go, `error` cannot be directly casted to `string` and vice versa.
The following two functions are used instead (located in `codegen/model/types/error.go`):
```go
func StringToError(s string) error {
	if s == "" {
		return nil
	}
	return errors.New(s)
}

func ErrorToString(err error) string {
	if err == nil {
		return ""
	}
	s := err.Error()
	if s == "" {
		panic("error.Error() must not return an empty string")
	}
	return s
}
```

#### The “origin” field for request-response events

Mir currently employs a special model for “request-response” events.
Both events contain a special field named `origin` (or `Origin`) that serves two purposes: (1) it contains the ID of the module that sent the request; and (2) it allows the module that made the request to recover the context in which the request was made.

Since these fields need special treatment, they should be marked with `[(mir.origin_request) = true]` or `[(mir.origin_response) = true]` respectively.

#### Other annotations

Annotation `[(mir.omit_in_event_constructors) = true]` can be used to omit a field from the constructor of the corresponding event type.

### Running the code generator

See `protos/generate.go`.

The code generator should be typically run using [go generate](https://go.dev/blog/generate), [GNU make](https://www.gnu.org/software/make/), a bash script, or another similar tool.
The following order is important to avoid circular dependencies (the examples are in the [go generate](https://go.dev/blog/generate) format):

1. Compile the protbuf extensions:
    ```go
    //go:generate -command protoc-basic protoc --proto_path=. --go_out=../pkg/pb/ --go_opt=paths=source_relative

    // Generate the code for codegen extensions.
    //go:generate protoc-basic mir/codegen_extensions.proto
    //go:generate protoc-basic dsl/codegen_extensions.proto
    //go:generate protoc-basic net/codegen_extensions.proto
    ```
2. Compile the protoc plugin:
   ```go
    //go:generate go build -o ../codegen/protoc-plugin/protoc-gen-mir ../codegen/protoc-plugin
    ```
3. Run `protoc` with this plugin enabled on the `.proto` files containing the definitions of Mir events:
    ```go
   //go:generate -command protoc-events protoc --proto_path=. --go_out=../pkg/pb/ --go_opt=paths=source_relative --plugin=../codegen/protoc-plugin/protoc-gen-mir --mir_out=../pkg/pb --mir_opt=paths=source_relative

    // Generate the protoc-generated code for events and messages.
    //go:generate protoc-events commonpb/commonpb.proto
    //go:generate protoc-events messagepb/messagepb.proto
    //go:generate protoc-events requestpb/requestpb.proto
    //go:generate protoc-events eventpb/eventpb.proto
    //...
    ```
4. Build and run the Mir code generator with the import path of the `protoc`-generated code as its input:
    ```go
    // Build the custom code generators.
    //go:generate go build -o ../codegen/generators/mir-std-gen/mir-std-gen.bin ../codegen/generators/mir-std-gen
    //go:generate -command std-gen ../codegen/generators/mir-std-gen/mir-std-gen.bin
    
    // Generate the Mir-generated code for events and messages.
    //go:generate std-gen "github.com/filecoin-project/mir/pkg/pb/eventpb"
    //go:generate std-gen "github.com/filecoin-project/mir/pkg/pb/messagepb"
    //go:generate std-gen "github.com/filecoin-project/mir/pkg/pb/bcbpb"
    //...
    ```

The Mir-generated code will be in sub-folders of the folder containing the protoc-generated code.

## Architecture

At the time of writing this README, Mir uses protobufs to represent events and network messages.
For a set of reasons (including flexibility, ease of implementation, and potential future migration to a different representation) the Mir code generator is *not* implemented as a protoc plugin.
Instead, it uses the Go code generated by `protoc` as its input.
It inspects this code using reflection.
Hence, the whole package containing the `protoc`-generated code must be compilable (i.e., contain no syntax errors).

We proceed by describing each of the components one by one.

### The protobuf extensions

Located in `protos/mir/codegen_extensions.proto`, `protos/dsl/codegen_extensions.proto`, and `protos/net/codegen_extensions.proto`.

These extensions are used to annotate the `.proto` definitions with Mir-specific information. See the “Annotating the .proto definitions” section for details.

#### Dependencies

None

### Parsing the protobuf extensions

Code located in `codegen/annotations.go`.

The code in this file simply checks if a certain message is marked with a certain annotation.
This file also contains an important function called `ShouldGenerateMirType`, which determines whether a given protobuf message should be processed by the Mir code generator.

#### Dependencies

The protobuf extensions must be compiled with `protoc`.

### protoc plugin

Located in `codegen/protoc-plugin/main.go`.

It is a tiny plugin that slightly enriches the reflection information of the `protoc`-generated code.
Namely, for each protobuf message marked with one of Mir annotations, for each `oneof` in this message, the plugin generates a method named `Reflect[OneofName]Options` that returns the information about all the options of the `oneof`.

#### Example

```protobuf
// Protobuf definition.
message RequestCertOrigin {
  option (mir.struct) = true;

  string module = 1 [(mir.type) = "github.com/filecoin-project/mir/pkg/types.ModuleID"];
  oneof type {
    contextstorepb.Origin context_store = 2;
    dslpb.Origin          dsl           = 3;
  }
}
```

```go
// Code generated by the plugin.
func (*RequestCertOrigin) ReflectTypeOptions() []reflect.Type {
	return []reflect.Type{
		reflect.TypeOf((*RequestCertOrigin_ContextStore)(nil)),
		reflect.TypeOf((*RequestCertOrigin_Dsl)(nil)),
	}
}
```

#### Dependencies

`github.com/filecoin-projct/mir/codegen` -- the plugin uses the `ShouldGenerateMirType` function.

### The `Generator` interface and the `RunGenerator` function

Located in `codegen/generator.go`.

Code generation in Mir is organized in a modular way.
There are many small generators.
All of them implement the same interface located in `codegen/generator.go`:
```go
type Generator interface {
	Run(structTypes []reflect.Type) error
}
```

The `Run` method of a code generator takes as input a list of all struct types exported by a package and may potentially return an error.

One non-trivial implication of using reflection to parse the input is that the input package must actually be compiled into the same binary as the code generator itself.
This is solved by the `RunGenerator` function located in `codegen/generator.go`:
```go
func RunGenerator[GeneratorType Generator](inputPkgPath string) error
```

This function acts as a meta-code-generator, i.e., it generates, compiles, and runs the code generator itself (see the implementation for details).
For this reason it accepts the code generator as a type parameter and imposes a few natural restrictions on it:
* It must be a concrete type that can be instantiated (i.e., not an interface).
* The type must be exported (i.e., start with a capital letter).
* It must be in a package that can be imported (i.e., not in a package named `main` or `internal`).

This list is likely to be not exhaustive and it is probably still possible to write a `Generator` that would satisfy all of these conditions but would not compile when passed to `RunGenerator`.
Hence, it is recommended to stay close to the existing examples in `codegen/generators`.

The `Run` method is invoked on a zero value of the generator type.

#### Example

See `codegen/generators/types-gen/generator/generator.go` for an example of a generator and `codegen/generators/types-gen/main.go` for an example of how to run it.

See `codegen/generators/mir-std-gen/generator/generator.go` and `codegen/generators/mir-std-gen/main.go` for an example of how multiple code generators can be composed into one.

#### Dependencies

None

### Parsing input and building a model

Code located in `codegen/model`.

The first thing that a code generator should do is to parse the input and build a model for it.
The most important part of the model and the parser for it are located in folder `codegen/model/types`.

Note that the parser is implemented using the [singleton pattern](https://en.wikipedia.org/wiki/Singleton_pattern) and contains a cache for already processed data.
This is done to avoid parsing the same data multiple times from multiple code generators.

## Standard code generators

TODO

## Creating a third-party code generator 

TODO
